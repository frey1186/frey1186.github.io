[OSTEP-6]操作系统如何在进程间进行切换.txt


假设是单核心CPU的情况下，用户进程在运行的时候操作系统并没有运行，那么进行如何切换到另外一个进程呢？
显然，进行进程的切换是操作系统的工作，那么操作系统如何获得这个权限呢？


1. 一个老办法：协作（cooperative）
其实就是等待用户进程自己放弃cpu，比如执行一个yield系统调用来放弃cpu，让操作系统获得计算机控制权限。
或者是比如应用进程执行了非法操作，比如除0操作，那么操作系统也可以获得权限。
但是，但是，如果用户进行因为某种原因，进入了死循环，没法执行yield，那就完犊子了。 ---唯一办法就是重启机器。
这方法真不咋地。

2. 一个不协作的办法，操作系统控制
办法就是时钟中断（timer interrupt），时钟中断由硬件提供，OS来编程实现它时钟中断的频率、中断处理程序；
需要在机器启动的时候将这些都设置好，一旦计时器启动，在一定的时间内，控制权都会回到操作系统；
和系统调用一样的，切换进程的过程中需要保存当前进程的状态，以便后面可以切换回来；
而且，操作系统也能够简单的处理掉那些恶意的进程。


那么如何保存上下文信息？
当操作系统再次获得计算机控制权的时候，它**必须**决定继续执行原来的进程还是切换进程；
做决定的这个部分叫做调度器（scheduler）。
如何调度，就是调度策略（scheduling policies），很重要，但是也很复杂。

上下文切换（context switch），
就是保存现有进程的一些寄存器的值---到内核栈上；恢复要执行的进程的一些寄存器的值---从内核栈上。
这个切换一般都是汇编代码实现。



有没有并发问题？concurrency

如果在执行一个系统调用的时候，时钟中断触发了，那该如何呢？   本书的并发部分会详细说明。
最简单的办法是，在执行中断处理程序的时候，关闭中断，不让有其他中断进来。但是这个要非常小心，关闭中断太长时间，可能会出现其他问题。
操作系统的锁，可以保护内部数据结构的并发访问方案，复杂但很有用，也许会产生让人很奇怪的BUG。


- 总结：

limited direct execution （有限的直接执行），好奇怪的名词。

===上下文切换需要多少时间？
2-3GHz 的CPU，一般在亚微妙级别。
但是一般来说性能的瓶颈不在CPU，而可能是内存、IO等等。。。。。

内核保护操作系统，就像爸爸妈妈保护婴儿一样，把所有不安全的地方都保护起来，让小孩子在里面的自由玩耍。



=== 关于CPU 虚拟化的一些术语

- user mode:
- kernel mode:
- system call:
- trap:  陷阱，或者说陷入内核
- trap table： 实际上就是系统调用的一个对应表
- return-from-trap: 从内核状态切换到用户状态，就是系统调用完成了， 返回user mode
- timer interrupt: 时钟中断，注意一定是在系统启动的时候就准备好了，而且用户必须没有权限修改
- context switch： 上下文切换


=== 一张重要的图

![](./timer-int-1.png)
![](./timer-int-2.png)